#include "sources.h"

//*************************************************************************//
// AUXILIAR //

void windowOpen(string imgName, const Mat &img, int xPos=0, int yPos=0) {

	namedWindow( imgName, WINDOW_AUTOSIZE );
	imshow( imgName, img );  
	moveWindow( imgName, xPos, yPos ); 

}

void drawSomething(Mat *img, int r1, int s1, int r2, int s2) {

	for(int i=0 ; i < 256 ; i++)
		for(int j=0 ; j < 256; j++)
			img->at<uchar>(i, j) = (uchar) 255;

	line(*img, Point(0, 255), Point(r1, 255-s1), 0, 4);
	line(*img, Point(255, 0), Point(r2, 255-s2), 0, 4);
	line(*img, Point(r1, 255-s1), Point(r2, 255-s2), 0, 4);
	circle(*img, Point(r1, 255-s1), 8, 0, -1);
	circle(*img, Point(r2, 255-s2), 8, 0, -1);
}

//*************************************************************************//

Mat computeHistogram1C (const cv::Mat &src) {

	// Establish the number of bins
	int histSize = 256;

	// Set the ranges ( for B,G,R) )
	float range[] = { 0, 256 } ;
	const float* histRange = { range };
	bool uniform = true; bool accumulate = false;

	Mat b_hist/*, g_hist, r_hist*/;

	// Compute the histograms:
	calcHist(	&src, 1, 0, Mat(), b_hist, 1, 
			&histSize, 
			&histRange, 
			uniform, 
			accumulate );

	// Draw the histograms for B, G and R
	int hist_w = 512; int hist_h = 400;
	int bin_w = cvRound( (double) hist_w/histSize );

	Mat histImage( hist_h, hist_w, CV_8UC1, Scalar( 0 ) );

	// Normalize the result to [ 0, histImage.rows ]
	normalize(b_hist, b_hist, 0, histImage.rows, NORM_MINMAX, -1, Mat() );

	// Draw for each channel
	for( int i = 1; i < histSize; i++ ) {

		line(	histImage, Point( bin_w*(i-1), 
			hist_h - cvRound(b_hist.at<float>(i-1)) ),
			Point( bin_w*(i), hist_h - cvRound(b_hist.at<float>(i)) ),
			Scalar( 255 ), 
			2, 8, 0 );
    }

    return histImage;
}

Mat scaleImage2_uchar (Mat &src){

	Mat tmp = src.clone();
	if (src.type()!= CV_32F){
		tmp.convertTo(tmp, CV_32F);
	}
	normalize(tmp,tmp,1,0, NORM_MINMAX);
	tmp = 255*tmp;
	tmp.convertTo(tmp, CV_8U, 1,0);
	return tmp;
}

Mat ffshift(const Mat &src){

	Mat tmp = src.clone();
	Mat tmp2;

	tmp = tmp (Rect(0,0,tmp.cols & -2, tmp.rows & -2));

	int cx = tmp.cols/2;
	int cy = tmp.rows/2;

	Mat q0(tmp, Rect(0,0,cx,cy));
	Mat q1(tmp, Rect(cx,0,cx,cy));
	Mat q2(tmp, Rect(0,cy,cx,cy));
	Mat q3(tmp, Rect(cx,cy,cx,cy));

	q1.copyTo(tmp2);
	q2.copyTo(q1);
	tmp2.copyTo(q2);

	q0.copyTo(tmp2);
	q3.copyTo(q0);
	tmp2.copyTo(q3);

	return tmp;
}

Mat applyLogTransform(const Mat &img){
	Mat mag = img.clone();
	mag +=1;
	log(mag,mag);
	return mag;
}

Mat createWhiteDisk (const int &rows, const int &cols, const int cx, const int cy, const int &radius){
    Mat img = Mat::zeros(rows, cols,CV_32F);
    for(int x =0; x <img.cols;x++){
        for(int y=0;y<img.rows;y++){
            float d= sqrt((x-cx)*(x-cx)+(y-cy)*(y-cy));
            if (d<=radius){
                //img.at<float>(y,x )= 1;
                img.at<float>(y,x )= 1-d/radius;
            }

        }
    }
    return img;



}

Mat createCosineImg(const int &rows, const int &cols, const float &freq, const float &theta) {
	Mat img = Mat::zeros(rows, cols, CV_32F);
	float rho;

	for (int x=0; x<img.cols; x++) {
		for(int y=0; y<img.rows; y++) {
			rho = x*cos(theta) - y*sin(theta);
			img.at<float> (y,x) = cos(CV_2PI*freq*rho);
		}
	}

	return img;
}


//*************************************************************************//
// HOME LESSONS //
//******************* [Jul/25] ******************//

void threeChannelHistogram() {

	Mat imgIn = imread("lena.png", CV_LOAD_IMAGE_COLOR);
	Mat imgOut = imgIn.clone();
	vector<Mat> imgChannel;

	split(imgOut, imgChannel);

	for(int i=0; i<imgChannel.size(); i++)
		imgChannel[i] = computeHistogram1C(imgChannel[i]);

	merge(imgChannel.data(), imgChannel.size(), imgOut);

	windowOpen("Original", imgIn, 0, 0);
	windowOpen("BGR Histogram", imgOut, 525, 0);
	waitKey(0);
}


//******************* [Ago/01] ******************//

void piecewiseLinearTransform() {

}


//*************************************************************************//
// EXPERIMENTS //
//*************** [Aug/01 and 03] ***************//

void laplacianSharpeningPt1() {

	Mat img  = imread("lena.png", IMREAD_GRAYSCALE);
	Mat img2, img3;
	img.convertTo(img,CV_32F);

	int factor = 5; // Sharpening Factor

	Mat kernel = (Mat_ <float>(3,3) <<
			1.0, 1.0,  1.0,
			1.0, -8.0, 1.0,
			1.0, 1.0,  1.0);

	filter2D(img, img2, CV_32F,kernel, Point(-1,-1),0,BORDER_DEFAULT);

	namedWindow( "img3", WINDOW_KEEPRATIO);
	moveWindow ( "img3", 450, 0 ); 
	createTrackbar("factor", "img3", &factor, 100, 0, 0);

	while(true){
		Mat hist = computeHistogram1C(img3);
		add(img, -(factor/100.0)*img2,img3,noArray(), CV_8U);

		imshow ("img3", scaleImage2_uchar(img3));
		imshow ("hist", hist);

		windowOpen("img2", scaleImage2_uchar(img2), 1000, 700); // Filtered
//		windowOpen("img", scaleImage2_uchar(img), 0, 0); 	// Original

		if((char)waitKey(5)=='q') 
			break;
	    }

}

void laplacianSharpeningPt2() {

	Mat img  = imread ("lena.png", IMREAD_GRAYSCALE);
	Mat lap, img2;

	Laplacian(img,lap,CV_32F,1,1,0);
	add(img, -lap,img2,noArray(), CV_8U);

	windowOpen("img", img, 0, 0);
	windowOpen("img2", img2, 450, 700);
	windowOpen("lap", lap, 1000, 0);

	waitKey(0);
}

void spatioGradientRun() {

Mat img  = imread ("lena.png", IMREAD_GRAYSCALE);
	Mat gx, gy,g;
	spatialGradient(img,gx,gy,3,BORDER_DEFAULT);
	g = abs(gx) + abs(gy);

	windowOpen("img", scaleImage2_uchar(img), 300, 700);
	windowOpen("g", scaleImage2_uchar(g), 600, 700);
	windowOpen("gx", scaleImage2_uchar(gx), 0, 0);
	windowOpen("gy", scaleImage2_uchar(gy), 1000, 0);

	waitKey(0);
}

//*************** [Aug/08 and 10] ***************//

void dftRun(bool setNormalize=false) {

	// Discrete Fourier Transform
	Mat img = imread("lena.png", IMREAD_GRAYSCALE);
	Mat planes[] = {Mat_<float>(img), Mat::zeros(img.size(), CV_32F)};
	Mat img2;

	if(! img.data ) {
        	cout <<  "Could not open or find the image" << std::endl ;
        	exit(1);
	}


	merge(planes, 2, img2);
	dft(img2, img2);
	split(img2, planes);

	Mat mag;
	magnitude(planes[0], planes[1], mag);
	mag = applyLogTransform(mag);

	if(setNormalize) {
		normalize(planes[0],planes[0],1,0,NORM_MINMAX);
		normalize(planes[1],planes[1],1,0,NORM_MINMAX);
	}

	windowOpen("planes_0", ffshift(planes[0]), 300, 700);
	windowOpen("planes_1", ffshift(planes[1]), 600, 700);
	windowOpen("img", scaleImage2_uchar(img), 0, 0);
	windowOpen("mag", ffshift(scaleImage2_uchar(mag)), 1000, 0);

	waitKey(0);
	
}

void whiteDisk() {

	Mat disk0= Mat::zeros(200,200, CV_32F);
        Mat disk = disk0.clone();
        namedWindow( "disk", WINDOW_AUTOSIZE);
	moveWindow( "disk", 0, 0 ); 

        int xc =100;
        int yc = 100;
        int radius = 20;

        createTrackbar("xc", "disk", &xc,disk.cols,0 );
        createTrackbar("yc", "disk", &yc,disk.rows,0 );
        createTrackbar("radius", "disk", &radius,disk.cols,0 );

        for (int x=0; x<disk.cols;x++)
            for(int y=0;y<disk.rows;y++)
                if ((x-xc)*(x-xc)+(y-yc)*(y-yc) <= radius*radius)
                    disk.at<float>(y,x)=1;
 
        while (true){
		disk = disk0.clone();
		disk = createWhiteDisk(200,200,xc,yc,radius);
		imshow("disk", disk);

		if((char)waitKey(1)=='q') 
			break;
        }

}

void lpfilter() {

	Mat img = imread("lena.png", IMREAD_GRAYSCALE);
	Mat img2 = img.clone();

	int radius = 50; // [0, 512] (512 = img.cols)
        namedWindow("mask", WINDOW_AUTOSIZE);
	createTrackbar("radius", "mask", &radius, img2.cols,0,0);
	moveWindow( "mask", 500, 700 ); 

	while(true) {

		Mat mask = createWhiteDisk (	img2.rows, 
						img2.cols, 
						(int)img2.cols/2, 
						(int)img2.rows/2,
						radius );

		mask = ffshift(mask);
		Mat planes[] = {Mat_<float>(img), Mat::zeros(img.size(), CV_32F)};

		merge(planes, 2 , img2);
		dft(img2, img2);
		split(img2, planes);

		multiply(planes[0], mask, planes[0]);
		multiply(planes[1], mask, planes[1]);
		merge(planes, 2, img2);
		idft(img2, img2, DFT_REAL_OUTPUT);
		img2 = ffshift(img2);

		//windowOpen("planes_0", ffshift(planes[0]), 300, 700);
		//windowOpen("planes_1", ffshift(planes[1]), 600, 700);

		imshow("mask", ffshift(mask));
		windowOpen("img", scaleImage2_uchar(img), 0, 0);
		windowOpen("img2", ffshift(scaleImage2_uchar(img2)), 1000, 0);

		if((char)waitKey(1)=='q') 
			break;
	}
}


void hpfilter() {

	Mat img = imread("lena.png", IMREAD_GRAYSCALE);
	Mat img2 = img.clone();

	int radius = 50; // [0, 512] (512 = img.cols)
        namedWindow("mask", WINDOW_AUTOSIZE);
	createTrackbar("radius", "mask", &radius, img2.cols,0,0);
	moveWindow( "mask", 500, 0 ); 

	while(true) {

		Mat mask = createWhiteDisk (	img2.rows, 
						img2.cols, 
						(int)img2.cols/2, 
						(int)img2.rows/2,
						radius );

		mask = ffshift(mask);
		mask = 1-mask; // <- Chage here for high/low pass
		Mat planes[] = {Mat_<float>(img), Mat::zeros(img.size(), CV_32F)};

		merge(planes, 2 , img2);
		dft(img2, img2);
		split(img2, planes);

		multiply(planes[0], mask, planes[0]);
		multiply(planes[1], mask, planes[1]);
		merge(planes, 2, img2);
		idft(img2, img2, DFT_REAL_OUTPUT);
		img2 = ffshift(img2);

		//windowOpen("planes_0", ffshift(planes[0]), 300, 700);
		//windowOpen("planes_1", ffshift(planes[1]), 600, 700);

		imshow("mask", ffshift(mask));
		windowOpen("img", scaleImage2_uchar(img), 0, 0);
		windowOpen("img2", ffshift(scaleImage2_uchar(img2)), 1000, 0);

		if((char)waitKey(1)=='q') 
			break;
	}
}

void sinusoidImg() {

	namedWindow("img", WINDOW_KEEPRATIO);
        Mat img;
        int rows = 500;
        int cols = 500;
        int freq = 1;
        int theta = 2;

        createTrackbar("Freq", "img", &freq, 500,0,0);
        createTrackbar("Theta", "img", &theta, 100,0,0);

        while(true){
		img = createCosineImg(	rows,cols,
					(float)freq/1e3, 
					(float)(CV_2PI*theta/100.0) );

		imshow("img", scaleImage2_uchar(img));

		if((char)waitKey(1)=='q') 
			break;
        }

}

void sinusoidNoise() {

	namedWindow("img", WINDOW_AUTOSIZE);
        namedWindow("mag", WINDOW_AUTOSIZE);

	moveWindow( "img", 0, 0 ); 
	moveWindow( "mag", 750, 0 ); 

        Mat img  = imread ("lena.png", IMREAD_GRAYSCALE);
        Mat noise;

        img.convertTo(img, CV_32F);
        img = img/255.0;

        int rows = img.rows;
        int cols = img.cols;

        int freq = 1;
        int theta= 2;
        int gain = 1;

        createTrackbar("Freq" , "img", &freq , 500,0,0);
        createTrackbar("Theta", "img", &theta, 100,0,0);
        createTrackbar("Gain" , "img", &gain , 100,0,0);

        while(true){
            noise = createCosineImg(rows,cols,(float)freq/1e3, (float)(CV_2PI*theta/100.0));
            noise = img + (float)(gain/100.0)*noise;

            Mat img3 = noise.clone();
            Mat img2, mag;
            Mat planes[] = {Mat_<float>(img3),Mat::zeros(img3.size(), CV_32F)};

            merge(planes,2,img2);
            dft(img2,img2);
            split(img2,planes);

            magnitude(planes[0], planes[1], mag);
            mag = applyLogTransform(mag);

            imshow("img", scaleImage2_uchar(noise));
            imshow("mag", ffshift(scaleImage2_uchar(mag)));

            if((char)waitKey(1)=='q') 
		break;
        }
}
